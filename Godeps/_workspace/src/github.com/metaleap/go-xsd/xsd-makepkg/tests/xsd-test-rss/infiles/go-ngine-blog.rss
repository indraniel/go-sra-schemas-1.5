<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by Site Server v6.0.0 (http://www.squarespace.com) on Mon, 12 Nov 2012 09:03:57 GMT--><rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>DevBlog - go:ngine</title><link>http://go-ngine.com/blog/</link><lastBuildDate>Sun, 28 Oct 2012 14:53:48 +0000</lastBuildDate><language>en-US</language><generator>Site Server v6.0.0 (http://www.squarespace.com)</generator><description></description><item><title>Now even works under Mac OS X...</title><category>Engine dev progress</category><dc:creator>go:ngine</dc:creator><pubDate>Sun, 28 Oct 2012 14:48:54 +0000</pubDate><link>http://go-ngine.com/blog/2012/10/28/now-even-works-under-mac-os-x</link><guid isPermaLink="false">507f8e7184aebdcd9b93536a:507f8e7184aebdcd9b93538c:508d45dbe4b09d6a6297afa2</guid><description><![CDATA[<p>under OpenGL 3.2 core profile only, that is. Of course. That means some rather recent version of OS X required -- not the latest but perhaps the one before -- not sure right now which version introduced OpenGL 3.2 for Mac users. Surreal feel to see my OpenGL Go code running as a native binary under OS X&nbsp; :)<br></p><img src="http://static.squarespace.com/static/507f8e7184aebdcd9b93536a/t/508d46cce4b01df297a0fc23/1351435988930/12-10-28-mac-os-x.png?format=500w" /><br/>]]></description></item><item><title>Yay, finally some decent timing stats!</title><category>Engine dev progress</category><dc:creator>go:ngine</dc:creator><pubDate>Sun, 28 Oct 2012 08:05:05 +0000</pubDate><link>http://go-ngine.com/blog/2012/10/28/yay-finally-some-decent-timing-stats</link><guid isPermaLink="false">507f8e7184aebdcd9b93536a:507f8e7184aebdcd9b93538c:508ce732e4b0b3e60effe78f</guid><description><![CDATA[<p>Now we're talking milliseconds and nanoseconds!</p><img src="http://static.squarespace.com/static/507f8e7184aebdcd9b93536a/t/508ce760e4b01df297a08642/1351411554167/golang-3d-engine-timing-fps-tracking-benchmark.png?format=500w" /><br/>]]></description></item><item><title>Hashing uints in Go</title><category>Coding</category><category>Go</category><category>Development</category><dc:creator>go:ngine</dc:creator><pubDate>Sat, 27 Oct 2012 05:20:37 +0000</pubDate><link>http://go-ngine.com/blog/2012/10/27/hashing-uints-in-go</link><guid isPermaLink="false">507f8e7184aebdcd9b93536a:507f8e7184aebdcd9b93538c:508b6f24e4b01df2979e331e</guid><description><![CDATA[<p>So I needed to hash three unsigned integers into one integer value uniquely identifying that particular combination of uints, to be used as a "hash key" in a <strong>map[int]sometype</strong>.</p><p>Simple arithmetics (add or mult) are out to uniquely hash different combinations: the set 1,2,4 should produce a different hash key than 1,4,2 and 2,1,4 and 2,4,1 and 4,1,2 and 4,2,1.<br></p><p>Found Robert Jenkins' 96 bit Mix Function with a neat source snippet right there (Java). Implemented in Go and seems to work even though I'm not sure if Golangs <strong>&gt;&gt;</strong> right-shift operator (spec'd as <strong>integer &gt;&gt; unsigned integer</strong>) really works like Java's <strong>&gt;&gt;&gt; "unsigned right shift"</strong>...</p><p><strong>Update:</strong> actually by now it dawned on me I can just use a <strong>[3]uint</strong> as a hash key in Golang here, which is fine in this use-case. Simplicity FTW!</p><p>But if you're curious about this topic, here's an <a href="http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633">incredible testing &amp; comparison of hashing algos</a>.</p><p></p>]]></description></item><item><title>Painless XML parsing in Go; plus, how to analyse your Go source tree for package references</title><category>Coding</category><category>OpenGL</category><category>Go</category><category>Parsing</category><category>Development</category><category>XML</category><dc:creator>go:ngine</dc:creator><pubDate>Fri, 19 Oct 2012 15:28:54 +0000</pubDate><link>http://go-ngine.com/blog/2012/10/19/painless-xml-parsing-in-go-plus-how-to-analyse-your-source-tree-for-package-references</link><guid isPermaLink="false">507f8e7184aebdcd9b93536a:507f8e7184aebdcd9b93538c:508171bce4b09ec41a87ca83</guid><description><![CDATA[<p>Getting seriously tricky stuff done in Go is, time and again, surprisingly simple.</p><p>Here's an interesting "convoluted custom" use-case I just had while working on <strong>go:ngine</strong>. So the engine is supposed to support OpenGL versions 3.2 or higher, but during development, 99% of the time I just run under OpenGL 4.2. To stay in the flow, I don't want to consult the GL specs every time I use a GL function or enumeration. At the same time, when I push to GitHub, I'd like to make sure any and all GL function or enumeration references in all go:ngine sources are either GL 3.2 or lower, or else wrapped in some conditional logic (ie. "only go ahead here if client GL version supports it")...</p><p>So for talking to OpenGL, go:ngine uses the <a href="http://github.com/chsc/gogl">fantastic GoGL ​binding</a>. Specifically it uses the <strong>gl42</strong> sub-package -- don't worry, that package even works under OpenGL 3.2! --- at least, <strong>if</strong> we <em>(A)</em> ignore the version-related error (but not any other kind of error) returned by <strong>gl42.Init()</strong> and <em>(B)</em> ensure we don't use API functions or enum values newer than the detected run-time GL version. So part <em>(A)</em> is easy, but ensuring <em>(B)</em> at all times (when mostly I happily develop using just my 4.2-capable GPU) could over time become an issue. What to do?<br></p><p>Ideally, I'd have a simple code checker tool that I would run just occasionally -- every other week, or right before major commits. It would:</p><ol><li>run over the entire​ go:ngine code-base</li><li>for each <em>.go</em> source file, collect all its references to the <strong>gl42</strong> package<br></li><li>record the name of every <strong>gl42</strong> function or enum value referenced​ (ignoring GL types here since from what I gather none have been added ever since 3.2)<br></li><li>​then for each such tracked reference, check a <a href="http://bitbucket.org/alfonse/gl-xml-specs/downloads">GL Specification XML file</a> for the minimum version that would support it<br></li><li>if the version for the func/enum reference is 3.2 or lower, ignore it​</li><li>otherwise, keep it and later show a summary like this:​</li></ol><blockquote>GL v4.2 used 4x:<br>&nbsp;&nbsp;&nbsp; function TexStorage2D:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-util\gl\buffers.go<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-util\gl\textures.go<br>&nbsp;&nbsp;&nbsp; function TexStorage3D:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-util\gl\textures.go<br>&nbsp;&nbsp;&nbsp; enum ATOMIC_COUNTER_BUFFER:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-util\gl\buffers.go<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-util\gl\counters.go<br>&nbsp;&nbsp;&nbsp; function TexStorage1D:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-util\gl\textures.go<br>GL v4.0 used 2x:<br>&nbsp;&nbsp;&nbsp; enum TESS_CONTROL_SHADER:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-ngine\client\glcore\shaders.go<br>&nbsp;&nbsp;&nbsp; enum TESS_EVALUATION_SHADER:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; c:\gd\src\github.com\go3d\go-ngine\client\glcore\shaders.go​</blockquote><p>The above is actually real output of said tool, because I just wrote it today in just a few hours and it's only a 100 lines or so in total! That's why I find Go amazingly fun to work with... (OK,&nbsp; maybe JavaScript could have done all this half the space, but I like statically-typed native-compiled code so anyway and Go's strict compiler saved me from a few bugs just right there today.)<br></p><ul><li>Parsing all <em>.go</em> source files was surprisingly simple just working off the <a href="http://golang.org/pkg/go/ast/">go/ast</a> and <a href="http://go-ngine.com#">go/parser</a> package examples.</li><li> Parsing the XML GL-specification file using the <a href="http://golang.org/pkg/encoding/xml/">encoding/xml</a> package <strong>would have been a major pain point</strong>, but before even taking the trouble to write out all XML tags as Go structs (I didn't <em>really</em> want to "unmarshal" anything, thanks very much...), I luckily came across the awesome <a href="http://github.com/go-forks/go-pkg-xmlx">go-pkg-xmlx</a> package -- it made loading and searching the 1.4MB spec file painless and also crucially, <strong>Just-Worked</strong> right off the bat! Kudos to <a href="http://github.com/jteeuwen/">jteeuwen</a>, once again great work and a superb contribution to the Go eco-system. (go:ngine also uses his <a href="http://github.com/go-gl/glfw">Go GLFW binding</a>, which also works a <em>charm</em> across platforms. Yay!)<br></li></ul><p>If you wanna see (or use) the code to parse the .go source tree, load the XML spec and checks any and all <strong>gogl/gl42​</strong> references across a given code-base against specific OpenGL versions, <a href="http://github.com/go3d/go-ngine/tree/master/_tools/gl_imp_parser_version_checker">it's right here on GitHub</a>.<br></p>]]></description></item><item><title>First post! Actually, post zero.</title><dc:creator>go:ngine</dc:creator><pubDate>Thu, 18 Oct 2012 07:30:53 +0000</pubDate><link>http://go-ngine.com/blog/2012/10/18/first-post-actually-post-zero</link><guid isPermaLink="false">507f8e7184aebdcd9b93536a:507f8e7184aebdcd9b93538c:507fb02b84aebdcd9b9396e0</guid><description><![CDATA[<p>​I'm too eager to get back to coding this thing, so I'll catch up with y'all here later (yeah, yeah)... just testing the blogging engine here.<br></p>]]></description></item></channel></rss>
